;AUTHOR NEVRA GÃœRSES
;161044071

;Reads file.
(defun readFile (filename)
	(let ( (file (open filename :if-does-not-exist nil))(str (string "")) (lex (list ))(res nil)(occur "")) 
		(setq defineNewline 0)
		(when file
			(loop for inner = (read-line file nil) ;loop for reading each line until document ends.
			    while inner
					do 
					(when (and (equal(char inner 0 ) #\; ) (equal(char inner 1 ) #\; )) ;This control to determine comment line.
                        (setq lex (lexer ";; "))
                        (setq  res (parser lex))
                        (when (not (equal res "error" ))
                            (print "SYNTAX OK.")(terpri)
                            (format t "Result :~a " res) 
                        )
                        (terpri)
					)
                    (when (not (and (equal(char inner 0 ) #\; ) (equal(char inner 1 ) #\; ))) 
                        (setq lex (lexer inner))
                        (setq  res (parser lex))
                        (when (not (equal res "error" ))
                            (print "SYNTAX OK.")(terpri)
                            (format t "Result :~a " res) 
                        )
                        (terpri)
					)		
			)
			(close file) ;closing file.
		)
	)
)
; Implementing lexer. 
(defun lexer (input)
	(let ((firstList (list )) (tokenList (list )) (totalList (list )) (flagValue 0) (flag 0) (flagIdentifier 0)(flagInner 0) (control 0) (controlVal 0) (interpreterList (list )) (innerList (list )))
        
        (setq input (string-downcase input))
		(setq list (list #\+  #\- #\/ #\* #\( #\) #\" #\, #\space ) ) ;to keep operators in list for some controls.
		(loop for i from 0 to (-(length input)1) ;loop until end of string
			do
		
			(setq symbol (char input i)) ;assign currently character in variable named symbol.
		
			;This conditions to determine operators.
			(when (and(equal symbol #\;) (equal (char input (+ i 1)) #\;))
                (setq innerList (append innerList (list symbol)))
                (setq innerList (append innerList (list (char input (+ i 1)))))
                (setq interpreterList (append interpreterList (list innerList)))
                
                (setq tokenList (append tokenList (list "COMMENT")))
				(setq control 1)
			)
			(when (equal symbol #\+) 
                (setq innerList (append innerList (list symbol)))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "OP_PLUS")))
				(setq control 1)
			)
			(when (equal symbol #\-) 
                (setq innerList (append innerList (list symbol)))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "OP_MINUS")))
				(setq control 1)
			
			)
			(when (equal symbol #\/) 
                (setq innerList (append innerList (list symbol)))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "OP_DIV")))
				(setq control 1)
			
			)
			(when (and(equal symbol #\*)(< (+ i ) (length input) )(not (equal (char input (+ i 1))  #\*))(not (equal (char input (- i 1))  #\*)))
               (setq innerList (append innerList (list symbol)))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "OP_MULT")))
				(setq control 1)
			
			)
			(when (equal symbol #\( )  
                (setq innerList (append innerList (list symbol)))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "OP_OP")))
				(setq control 1)
			)
			(when (equal symbol #\) )  
                (setq innerList (append innerList (list symbol)))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "OP_CP")))
				(setq control 1)
			)
			(when (and (equal symbol #\*) (< (+ i 1) (length input) )(equal (char input (+ i 1))  #\*)) 
               (setq innerList (append innerList (list symbol)))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "OP_DBLMULT")))
				(setq control 1)
			
			)
            (when (and (equal symbol #\') (< (+ i 1) (length input) )(equal (char input (+ i 1))  #\()) 
               (setq innerList (append innerList (list symbol)))
               (setq innerList (append innerList (list (char input (+ i 1)))))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "OP_LIST")))
				(setq control 1)
                (setq i (+ i 1))
			
			)
			(when (and (equal symbol #\" ) )
				( cond ((equal flag 0) ;this conditon to determine " character whether oc or cc.
                    (setq innerList (append innerList (list symbol)))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "OP_OC")))
					(setq flag 1))
					( 
                        (setq innerList (append innerList (list symbol)))
                        (setq interpreterList (append interpreterList (list innerList)))
                        (setq innerList nil)
                        (setq tokenList (append tokenList (list "OP_CC")))
					    (setq flag 0))

					)
					(setq control 1)
			)	
			(when (equal symbol #\, )  
                (setq innerList (append innerList (list symbol)))
                (setq interpreterList (append interpreterList (list innerList)))
                (setq innerList nil)
                (setq tokenList (append tokenList (list "COMMA")))
				(setq control 1)
			)
			;This condition to determine value.
			(when (equal (isDigit symbol) t)
					;This condition determine 0 as value.
					(when (and (equal symbol #\0) (< (+ i 1) (length input) )(equal (isDigit (char input (+ i 1)) ) nil ) (equal (isDigit (char input (- i 1)) ) nil ))
                        (setq innerList (append innerList (list symbol)))
                        (setq interpreterList (append interpreterList (list innerList)))
                        (setq innerList nil)
                        (setq tokenList (append tokenList (list "VALUE")))
						(setq control 1)
					)
					;This condition determine the start of value.	
					(when (and (not (equal symbol #\0)) (equal (isDigit (char input (- i 1)) ) nil )(equal (isAlphabetical (char input (- i 1)) ) nil ))
						(setq flagValue 1)
						(setq control 1)

					)
					;This condition determine value that no leading zero.
					(when (and  (equal flagValue 1 ) (< (+ i 1) (length input) )(equal (isDigit (char input (+ i 1)) ) nil ))
                        (setq innerList (append innerList (list symbol)))
                        (setq interpreterList (append interpreterList (list innerList)))
                        (setq innerList nil)
                        (setq tokenList (append tokenList (list "VALUE")))
						(setq flagValue 0)
						(setq control 1)
					)	
					(when (equal flagValue 1)
                        (setq innerList (append innerList (list symbol)))
						(setq control 1)
					)			
			)
			;This conditions determine keywords.For tall keywords I use subseq equivalence control and small keywords I use  each character equivelence control.
			;determine keyword and.
			(when (and(equal symbol #\a )  (< (+ i 3) (length input) )(equal (char input (+ i 1)) #\n )(equal (char input (+ i 2)) #\d )(not (equal (position (char input (+ i 3) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_AND")))
					(setq flagIdentifier 1)
					(setq i (+ i 2))
					(setq control 1)
			)
			;determine keyword or.
			(when (and(equal symbol #\o )  (< (+ i 2) (length input) )(equal (char input (+ i 1)) #\r )(not (equal (position (char input (+ i 2) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_OR")))
					(setq flagIdentifier 1)
					(setq i (+ i 1))
					(setq control 1)
			)
			;determine keyword not.
			(when (and(equal symbol #\n )  (< (+ i 3) (length input) )(equal (char input (+ i 1)) #\o )(equal (char input (+ i 2)) #\t )(not (equal (position (char input (+ i 3) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_NOT")))
					(setq flagIdentifier 1)
					(setq i (+ i 2))
					(setq control 1)
			)
			;determine keyword equal.
			(when (and(equal symbol #\e ) (< (+ i 5) (length input) )(equal (subseq input (+ i 1) (+ i 5)) "qual") (not (equal (position (char input (+ i 5) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3)))))
                    (setq innerList (append innerList (list (char input (+ i 4)))))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_EQUAL")))
					(setq flagIdentifier 1)
					(setq i (+ i 4))
					(setq control 1)
			)
			;determine keyword less.
			(when (and(equal symbol #\l )  (< (+ i 4) (length input) )(equal (subseq input (+ i 1) (+ i 4)) "ess") (not (equal (position (char input (+ i 4) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)) )))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_LESS")))
					(setq flagIdentifier 1)
					(setq i (+ i 3))
					(setq control 1)
			)
            ;determine keyword exit
            (when (and(equal symbol #\e )  (< (+ i 4) (length input) )(equal (subseq input (+ i 1) (+ i 4)) "xit") (not (equal (position (char input (+ i 4) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)) )))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_EXIT")))
					(setq flagIdentifier 1)
					(setq i (+ i 3))
					(setq control 1)
			)
			;determine keyword nil.
			(when (and(equal symbol #\n )  (< (+ i 3) (length input) )(equal (char input (+ i 1)) #\i )(equal (char input (+ i 2)) #\l )(not (equal (position (char input (+ i 3) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_NIL")))
					(setq flagIdentifier 1)
					(setq i (+ i 2))
					(setq control 1)
			)
			;determine keyword list.
			(when (and(equal symbol #\l )  (< (+ i 4) (length input) )(equal (subseq input (+ i 1) (+ i 4)) "ist") (not (equal (position (char input (+ i 4) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)) )))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_LIST")))
					(setq flagIdentifier 1)
					(setq i (+ i 3))
					(setq control 1)
			)
			;determine keyword append.
			(when (and(equal symbol #\a )  (< (+ i 6) (length input) )(equal (subseq input (+ i 1) (+ i 6)) "ppend") (not (equal (position (char input (+ i 6) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3)))))
                    (setq innerList (append innerList (list (char input (+ i 4)))(list (char input (+ i 5))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_APPEND")))
					(setq flagIdentifier 1)
					(setq i (+ i 5))
					(setq control 1)
			)
			;determine keyword concat.
			(when (and(equal symbol #\c )  (< (+ i 6) (length input) )(equal (subseq input (+ i 1) (+ i 6)) "oncat") (not (equal (position (char input (+ i 6) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3)))))
                    (setq innerList (append innerList (list (char input (+ i 4)))(list (char input (+ i 5))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_CONCAT")))
					(setq flagIdentifier 1)
					(setq i (+ i 5))
					(setq control 1)
			)
			;determine keyword set.
			(when (and(equal symbol #\s )  (< (+ i 3) (length input) )(equal (char input (+ i 1)) #\e )(equal (char input (+ i 2)) #\t )(not (equal (position (char input (+ i 3) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_SET")))
					(setq flagIdentifier 1)
					(setq i (+ i 2))
					(setq control 1)
					
			)
			;determine keyword deffun.
			(when (and(equal symbol #\d )  (< (+ i 6) (length input) )(equal (subseq input (+ i 1) (+ i 6)) "effun") (not (equal (position (char input (+ i 6) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3)))))
                    (setq innerList (append innerList (list (char input (+ i 4)))(list (char input (+ i 5))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_DEFFUN")))
					(setq flagIdentifier 1)
					(setq i (+ i 6))
					(setq control 1)
			)
            ;determine keyword defvar
            (when (and(equal symbol #\d )  (< (+ i 6) (length input) )(equal (subseq input (+ i 1) (+ i 6)) "efvar") (not (equal (position (char input (+ i 6) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3)))))
                    (setq innerList (append innerList (list (char input (+ i 4)))(list (char input (+ i 5))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_DEFVAR")))
					(setq flagIdentifier 1)
					(setq i (+ i 6))
					(setq control 1)
			)
			;determine keyword for.
			(when (and(equal symbol #\f )  (< (+ i 3) (length input) )(equal (char input (+ i 1)) #\o )(equal (char input (+ i 2)) #\r )(not (equal (position (char input (+ i 3) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_FOR")))
					(setq flagIdentifier 1)
					(setq i (+ i 2))
					(setq control 1)
			)
			;determine keyword if.
			(when (and(equal symbol #\i )  (< (+ i 2) (length input) )(equal (char input (+ i 1)) #\f )(not (equal (position (char input (+ i 2) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_IF")))
					(setq flagIdentifier 1)
					(setq i (+ i 1))
					(setq control 1)
			)
			;determine keyword exit.
			(when (and(equal symbol #\e )  (< (+ i 4) (length input) )(equal (subseq input (+ i 1) (+ i 4)) "xit") (not (equal (position (char input (+ i 4) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)) )))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_EXIT")))
					(setq flagIdentifier 1)
					(setq i (+ i 3))
					(setq control 1)
			)
			;determine keyword load.
			(when (and(equal symbol #\l ) (< (+ i 4) (length input) ) (equal (subseq input (+ i 1) (+ i 4)) "oad") (not (equal (position (char input (+ i 4) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)) )))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_LOAD")))
					(setq flagIdentifier 1)
					(setq i (+ i 3))
					(setq control 1)
			)
			;determine keyword disp.
			(when (and(equal symbol #\d )  (< (+ i 4) (length input) )(equal (subseq input (+ i 1) (+ i 4)) "isp") (not (equal (position (char input (+ i 4) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)) )))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_DISP")))
					(setq flagIdentifier 1)
					(setq i (+ i 3))
					(setq control 1)
			)
			;determine keyword true.
			(when (and(equal symbol #\t )  (< (+ i 4) (length input) )(equal (subseq input (+ i 1) (+ i 4)) "rue") (not (equal (position (char input (+ i 4) ) list )nil )))
                    (setq innerList (append innerList (list symbol)(list (char input (+ i 1)) )))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3))) ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_TRUE")))
					(setq flagIdentifier 1)
					(setq i (+ i 3))
					(setq control 1)
			)
            ;determine keyword while
            (when (and(equal symbol #\w ) (< (+ i 5) (length input) ) (equal (subseq input (+ i 1) (+ i 5)) "hile") (not (equal (position (char input (+ i 5) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3)))))
                    (setq innerList (append innerList (list (char input (+ i 4)))))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_WHILE")))
					(setq flagIdentifier 1)
					(setq i (+ i 4))
					(setq control 1)
			)
			;determine keyword false.
			(when (and(equal symbol #\f ) (< (+ i 5) (length input) ) (equal (subseq input (+ i 1) (+ i 5)) "alse") (not (equal (position (char input (+ i 5) ) list )nil )))
                    (setq innerList (append innerList (list symbol) (list (char input (+ i 1)))))
                    (setq innerList (append innerList (list (char input (+ i 2)))(list (char input (+ i 3)))))
                    (setq innerList (append innerList (list (char input (+ i 4)))))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq innerList nil)
                    (setq tokenList (append tokenList (list "KW_FALSE")))
					(setq flagIdentifier 1)
					(setq i (+ i 4))
					(setq control 1)
			)
			;This condition determine identifiers.
			(when (and (equal flagIdentifier 0)(or(equal (isAlphabetical symbol) t ) (equal flagInner 1)))
				(setq control 1) 
                (setq innerList (append innerList (list symbol)))
				(when  (equal (isDigit(char input (+ i 1))) t) ;identifier can include digits.
						(setq flagInner 1)
						(setq control 1)

				)
				;This condition determine end of identifier.
				(when  (not (equal (position (char input (+ i 1) ) list )nil ))
                    (setq interpreterList (append interpreterList (list innerList)))
                    (setq tokenList (append tokenList (list "IDENTIFIER")))
                    (setq innerList nil)
				    (setq flagInner 0)
                     
					(setq control 1)
				)
			)
			;this condition prevent to give error for space ,newline, ; , tab.  
			(when (or(equal symbol #\space )(equal symbol #\newline)(equal symbol #\*)(equal symbol #\;)(equal symbol #\tab))
				(Setq control 1)
			) 
			;This condition for giving error message if false lexeme entered.
			(when (equal control 0)
					(format t "SYNTAX_ERROR ~a cannot be tokenized!" symbol)(terpri)
				(return nil)
			
			)
			(setq flagIdentifier 0)
			(setq control 0)		
		)
        (setq interpreterList (listToString interpreterList))
        (loop for n from 0 to ( - (list-length interpreterList) 1 )
			do
                (setq firstList (append firstList (list (nth n interpreterList))(list (nth n tokenList)) ))
                (setq totalList (append totalList (list firstList)))
                (setq firstList nil)
				
		)	
        totalList	
       
	)
)
;This function converts list to string.
(defun listToString (list)
    (let ( (strList (list )))
        (loop for k from 0 to (-( length list) 1)
            do
            (setq strList (append strList (list (coerce  (nth k list ) 'string))))             
        )
        strList
    )
)
;This is parser function to make syntax analiysis.
(defun parser (input)
    (let ((detect 0)(flagAfter 1)(flagError 1) (i 0  )(flag 0) (sum 0 )(control 0)(keep 0)(errorDetect 1)(logic t)(val1 ) (val2 )(check nil)(result )(lst (list ))(tempList (list )))
        (Setq errorDetect (parenthesesDetection input))
        (Setq detect 0)
        (when (equal  errorDetect 0)  
            ;Makes syntax analiysis for (+ EXPI EXPI) 
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "+"))
                (let ( (sum 0)(flagError 1 ) (flagAfter 1)(keep 0 )(control 0)(flag 0)(res 0)) 
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (Setq flagError 1)
                        (when  (and(equal (nth  1 (nth i input) ) "VALUE") (equal control 0))
                            (setq flagError 0)
                            (setq sum (+ sum (parse-integer (nth  0 (nth i input) ))))
                        )
                        (when (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (setq control 1)
                            (setq flagError 0)
                            (Setq flagAfter 0)
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (setq flagError 0)
                            (Setq flagAfter 1)
                        ) 
                        (when (and (equal flagAfter 1 ) (equal (nth  1 (nth i input) ) "VALUE"))
                            (setq flagError 0)
                        )
                        (when (equal (nth  0 (nth i input) ) ")") 
                            (Setq flagError 0)
                        )
                        (when  (and (equal flag  0) (equal control 1 )) 
                            (setq control 0)
                            (setq flagError 0)
                            (setq res (parser ( subseq input keep (+ i 1))))
                            (when (typep res 'integer)
                                (Setq sum (+ sum res))
                                (setq flagError 0)
                            ) 
                            (when (not (typep res 'integer))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                 ( return-from parser "error")
                            )  
                            (Setq flagAfter 1)     
                        ) 
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized  ")
                             ( return-from parser "error")
                        )    
                    ) 
                    (setq result sum)
                ) 
                (setq detect 1)    
            )
            ;Makes syntax analiysis for (* EXPI EXPI)                           
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "*"))
                (let ( (flag 0)(control 0)  (mult 1 ) (flagError 1 ) (flagAfter 1)(res 0)(keep 0)) 
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (Setq flagError 1)
                        (when   (and (equal (nth  1 (nth i input) ) "VALUE")(equal control 0)) 
                            (setq mult (* mult (parse-integer (nth  0 (nth i input) ))))
                            (Setq flagError 0)
                        )
                        (when   (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (Setq flagError 0)
                            (setq control 1)
                            (setq flagAfter 0)
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (Setq flagError 0)
                            (Setq flagAfter 1)
                            
                        ) 
                        (when (equal (nth  0 (nth i input) ) ")") 
                            (Setq flagError 0)
                        )
                        (when (and (equal flagAfter 1 ) (equal (nth  1 (nth i input) ) "VALUE"))
                            (setq flagError 0)
                        )
                        (when  (and (equal flag  0)(equal control 1 ))
                            (Setq control 0)
                            (setq res (parser ( subseq input keep (+ i 1))))
                            (setq flagError 0)
                            (when (typep res 'integer)
                                (setq flagError 0)
                                (Setq mult (* mult res ))
                            )
                            (when (not (typep res 'integer))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                ( return-from parser "error")
                            )       
                        )
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )         
                    )
                    (setq result mult)
                )
                (setq detect 1)                             
            )
            ;Makes syntax analiysis for (- EXPI EXPI) 
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "-")) 
                (let ( (flag 0)(start 0) (flagRec 0  )(important 0) (diff 0 )(control 0)(res 0)(keep 0))
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (setq flagError 1)
                        (when   (and (equal (nth  1 (nth i input) ) "VALUE")(equal control 0)) 
                            (when (equal start 0)
                                (setq diff (- (parse-integer (nth  0 (nth i input) )) diff ))
                                (setq important 1)
                                (setq flagError 0)
                            ) 
                            (when (equal start 1)
                                (setq diff (- diff (parse-integer (nth  0 (nth i input) ))))
                                (setq start 0)
                                (setq important 0)
                                (setq flagError 0)
                            )   
                            (setq start 1) 
                        )
                        (when   (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (setq control 1)
                            (setq start 1)  
                            (setq flagError 0)
                            (setq flagAfter 0)
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (setq flagError 0)
                            (setq flagAfter 1)
                            
                        ) 
                        (when (equal (nth  0 (nth i input) ) ")") 
                            (Setq flagError 0)
                        )
                        (when (and (equal flagAfter 1 ) (equal (nth  1 (nth i input) ) "VALUE"))
                            (setq flagError 0)
                        )
                        (when  (and (equal flag  0)(equal control 1 ))
                            (Setq control 0)
                            (setq flagError 0)
                            (setq res  (parser ( subseq input keep (+ i 1))))
                            (when (typep res 'integer)
                                (when (equal important 0)
                                    (Setq diff (- res diff))
                                )
                                (when (equal important 1)
                                    (Setq diff (- diff res))
                                )  
                            ) 
                            (when (not (typep res'integer))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                 ( return-from parser "error")
                            )         
                        ) 
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )      
                    ) 
                    (setq result diff) 
                )
                (Setq detect 1) 
                result                     
            )
            ;Makes syntax analiysis for (/ EXPI EXPI) 
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "/"))
                (let ( (flag 0)(start 0) (flagRec 0  )(important 0) (div 1 )(control 0)(res 0)(keep 0)) 
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (setq flagError 1)
                        (when   (and (equal (nth  1 (nth i input) ) "VALUE")(equal control 0)) 
                            (when (equal start 0)
                                (setq div (/ (parse-integer (nth  0 (nth i input) )) div ))
                                (setq important 1)
                                (setq flagError 0)
                            ) 
                            (when (equal start 1)
                                (setq div (/ div (parse-integer (nth  0 (nth i input) ))))
                                (setq start 0)
                                (setq important 0)
                                (setq flagError 0)
                            )  
                            (setq start 1) 
                        )
                        (when   (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (setq control 1)
                            (setq start 1) 
                            (setq flagError 0)
                            (setq flagAfter 0) 
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (setq flagError 0)
                            (setq flagAfter 1)
                            
                        )
                        (when  (equal (nth  0 (nth i input) ) ")" )
                            (setq flagError 0)
                            
                        ) 
                        (when (and (equal flagAfter 1 ) (equal (nth  1 (nth i input) ) "VALUE"))
                            (setq flagError 0)
                        ) 
                        (when  (and (equal flag  0)(equal control 1 ))
                            (Setq control 0)
                            (setq flagError 0)
                            (setq res (parser ( subseq input keep (+ i 1))))
                            (when (typep res 'integer)
                                (when (equal important 0)
                                    (Setq div (/ res div))
                                )
                                (when (equal important 1)
                                    (Setq div (/ div res))
                                )
                                (setq flagError 0)    
                            )
                            (when (not (typep res'integer))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )         

                        )       
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )                
                      
                    )
                    (setq result div)     
                )
                (setq detect 1)            
            )
            ;Makes syntax analiysis for  (Id EXPLISTI) 
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 1  (nth (+ i 1) input)  ) "IDENTIFIER")) 
                (let ( (flag 0)(identifier 0)(control 0) (index 0) (mult 1 ) (flagError 1 ) (flagAfter 1)(res nil)(keep 0)(j 0)(num 0)) 
                    (Setq identifier (nth 0  (nth (+ i 1) input) ))
                    (loop for i from 2 to (-( length input ) 1)
                        do
                            (setq flagError 1)
                            (when (or (equal (nth  0 (nth i input) ) "(") (equal (nth  0 (nth i input) ) "'("))
                                    (when (equal flag 0)
                                        (setq keep i)
                                    )
                                    (Setq index i)
                                    (setq flagError 0)
                                    (setq flag ( + flag 1 )) 
                                    (setq control 1)
                                    (setq flagAfter 0)
                                    (setq first 1)  
                            )
                            (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1) )
                                    (setq flagError 0)
                                    (setq flag (- flag 1)) 
                                    (setq flagAfter 1)   
                            ) 
                            (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                            )
                            (when  (and (equal flag  0)(equal control 1 ))
                                    (Setq control 0)
                                    (Setq flagError 0)
                                    (Setq res (parser ( subseq input keep (+ i 1))))
                                    (setq num (+ num 1))
                                    (when (typep res 'CONS)
                                            (terpri)
                                            (format t "~a :~a "  identifier res) 
                                        
                                    )
                                    (when  (not (typep res 'CONS))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                        
                                    )
                            )
                            (when (and (equal flagError 1)( equal flagAfter 1))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            ) 
                            (when (and ( not (equal num 1))( not (equal num 0))) 
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )         
                    )
                    (setq result res) 
                )
                (setq detect 1)    
            )
            ;Makes syntax analiysis for  (and EXPB EXPB)
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "and"))
                (let ( (flag 0)(logic t)(control 0) (flagError 1 ) (flagAfter 1)(res nil)(keep 0))  
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (setq flagError 1)
                        (when  (and (equal (nth  1 (nth i input) ) "KW_TRUE")(equal control 0))
                            (setq logic (and logic t))
                            (setq flagError 0 )
                        )
                        (when  (and (equal (nth  1 (nth i input) ) "KW_FALSE")(equal control 0))
                            (setq logic (and logic nil))
                            (setq flagError 0 )
                        )
                        (when   (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (setq control 1)
                            (setq flagError 0 )
                            (setq flagAfter 0 )
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (setq flagError 0 )
                            (setq flagAfter 1 )
                            
                        )
                        (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                        ) 
                        (when  (and (equal flag  0)(equal control 1 ))
                            (Setq control 0)
                            (Setq flagError 0)
                            (Setq res (parser ( subseq input keep (+ i 1)) ))
                            (when (typep res 'BOOLEAN)
                                (setq logic (and logic res))
                            )            
                            (when  (not (typep res 'BOOLEAN))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")            
                            )
                            (Setq flagError 0)    
                        )
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )   

                    )
                    (setq result logic)
                )           
                (Setq detect 1)
            )
            ;Makes syntax analiysis for  (or EXPB EXPB)
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "or"))
                (let ( (flag 0)(logic nil)(control 0) (flagError 1 ) (flagAfter 1)(res nil)(keep 0))   
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (setq flagError 1)
                        (when  (and (equal (nth  1 (nth i input) ) "KW_TRUE")(equal control 0))
                            (setq logic (or logic t))
                            (setq flagError 0)
                        )
                        (when  (and (equal (nth  1 (nth i input) ) "KW_FALSE")(equal control 0))
                            (setq logic (or logic nil))
                            (setq flagError 0)
                        )
                        (when   (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (setq control 1)
                            (setq flagError 0)
                            (setq flagAfter 0)
                        
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (setq flagError 0)
                            (setq flagAfter 1)
                            
                        ) 
                        (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                        ) 
                        (when  (and (equal flag  0)(equal control 1 ))
                            (Setq flagError 0)
                            (Setq res (parser ( subseq input keep (+ i 1)) ))
                            (when (typep res 'BOOLEAN)
                                (setq logic (or logic res))
                            )            
                            (when  (not (typep res 'BOOLEAN))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")           
                            )
                            (setq flagError 0)    
                        )
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized  ")
                             ( return-from parser "error")
                        )  
                    )
                    (setq result logic)
                )
                (setq detect 1)          
            )
            ;Makes syntax analiysis for  (not EXPB)
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "not"))
                (let ( (flag 0)(logic nil)(control 0) (flagError 1 ) (flagAfter 1)(res nil)(keep 0)(num 0)) 
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (setq flagError 1)
                        (when  (and (equal (nth  1 (nth i input) ) "KW_TRUE")(equal control 0))
                            (setq logic t)
                            (setq num (+ num 1))
                            (setq flagError 0) 
                        )
                        (when  (and (equal (nth  1 (nth i input) ) "KW_FALSE")(equal control 0))
                            (setq logic nil)
                            (setq num (+ num 1))
                            (setq flagError 0) 
                        )
                        (when   (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (setq control 1)
                            (setq flagError 0) 
                            (setq flagAfter 0) 
                     
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (setq flagError 0) 
                            (setq flagAfter 1) 
                            
                        )
                         (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                        )  
                        (when  (and (equal flag  0)(equal control 1 ))
                            (Setq control 0)
                            (setq flagError 0) 
                            (setq num (+ num 1))
                            (setq res (parser ( subseq input keep (+ i 1))))
                            (when (typep res 'BOOLEAN)
                                (setq logic (not res))
                            )            
                            (when  (not (typep res 'BOOLEAN))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                 ( return-from parser "error")            
                            )
                            (setq flagError 0)    
                        )
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )
                        (when (and ( not (equal num 1))( not (equal num 0))) 
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )       

                    ) 
                    (setq result logic)      
                )
                (setq detect 1) 
            )
            ;Makes syntax analiysis for  (equal  EXPB EXPB) and (equal EXPI EXPI)
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "equal"))
                (let ( (flag 0)(logic nil)(control 0) (flagError 1 ) (flagAfter 1)(res nil)(keep 0)(num 0)(val1 nil)(val2 nil))  
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (setq flagError 1)
                        (when  (and (or (equal (nth  1 (nth i input) ) "VALUE") (equal (nth  1 (nth i input) ) "KW_FALSE") (equal (nth  1 (nth i input) ) "KW_TRUE"))(not (equal val1 nil))(equal val2 nil)(equal control 0))
                            (when (equal (nth  1 (nth i input) ) "VALUE")
                                (setq val2 (parse-integer (nth  0 (nth i input) )))
                                (setq flagError 0 )
                            ) 
                            (when (equal (nth  1 (nth i input) ) "KW_FALSE")
                                (setq val2 nil )
                                (setq flagError 0 )
                            
                            )
                            (when (equal (nth  1 (nth i input) ) "KW_TRUE")
                                (setq val2 t )
                                (setq flagError 0 )
                            )      
                        )
                        (when  (and  (or (equal (nth  1 (nth i input) ) "VALUE") (equal (nth  1 (nth i input) ) "KW_FALSE") (equal (nth  1 (nth i input) ) "KW_TRUE"))(equal val1 nil)(equal control 0) )
                            (when (equal (nth  1 (nth i input) ) "VALUE")
                                (setq val1 (parse-integer (nth  0 (nth i input) )))
                                (setq flagError 0 )
                            ) 
                            (when (equal (nth  1 (nth i input) ) "KW_FALSE")
                                (setq val1 nil )
                                (setq flagError 0 )
                            
                            )
                            (when (equal (nth  1 (nth i input) ) "KW_TRUE")
                                (setq val1 t )
                                (setq flagError 0 )
                            
                            )      
                        )
                        (when   (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (setq control 1)
                            (setq flagError 0 )
                            (setq flagAfter 0 )
                        
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (setq flagError 0 )
                            (setq flagAfter 0 )
                            
                        ) 
                        (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                        )
                        (when  (and (not (equal val1 nil))(not (equal val2 nil)))
                            (when (and (not (equal (type-of val1 )(type-of val2)))(not (equal (integerp val1 )(integerp val2))))
                                (print "SYNTAX_ERROR Expression not recognized  ")
                                 ( return-from parser "error")
                            )
                            (setq logic (equal val1 val2))
                        ) 
                        (when  (and (equal flag  0)(equal control 1 ))
                            (Setq control 0)
                            (setq flagError 0)
                            (setq res  (parser ( subseq input keep (+ i 1))))
                            (when (or (typep res 'BOOLEAN)(typep res 'integer))
                                (when   (and (not(equal val1 nil))(equal val2 nil))
                                   (setq val2  res )
                                   (when (or (not (typep val2 'NULL)) (not (typep val1 'NULL)))
                                        (when (and (not (equal (type-of val1 )(type-of val2)))(not (equal (integerp val1 )(integerp val2))))
                                            (print "SYNTAX_ERROR Expression not recognized  ")
                                             ( return-from parser "error")
                                        )
                                   )       
                                )
                                (when   (equal val1 nil)
                                    (setq val1 res)
                                )
                                
                            )
                            (when (and (not (typep res 'BOOLEAN))(not(typep res 'integer)))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error") 
                            )      
                        )
                       
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized  ")
                             ( return-from parser "error")
                        )
                        (setq result logic)     
                    )
                )    
                (setq detect 1) 
            )
            ;Makes syntax analiysis for   â€˜( VALUES )    
            (when (equal (nth  0 (nth i input) ) "'(" )
                (let ( (lst (list ))(flagError 1) )   
                    (loop for i from 1 to (-( length input ) 1)
                        do  
                            (setq flagError 1)
                            (when   (equal (nth  1 (nth i input) ) "VALUE" )
                                (setq res (nth  0 (nth i input) ))
                                (Setq lst (append lst (list (parse-integer res ))))
                                (setq flagError 0)
                            )
                            (when  (equal (nth  0 (nth i input) )")")
                                (setq flagError 0)
                            )
                            (when (equal flagError 1)
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )       
                     )  
                     (Setq result lst)
                )
                (setq detect 1)     
            )
            ;Makes syntax analiysis for   ( list VALUES ) 
            (when (and (equal (nth  0 (nth i input) ) "(")(equal (nth  1 (nth (+ i 1) input) ) "KW_LIST") )
                (let ( (lst (list ))(flagError 1) )   
                    (loop for i from 2 to (-( length input ) 1)
                        do
                            (setq flagError 1)
                            (when   (equal (nth  1 (nth i input) ) "VALUE" )
                                (setq res (nth  0 (nth i input) ))
                                (Setq lst (append lst (list (parse-integer res ))))
                                (setq flagError 0)
                            )
                            (when  (equal (nth  0 (nth i input) )")")
                                (setq flagError 0)
                            )
                            (when (equal flagError 1)
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )       
                     )  
                     (Setq result lst)
                )
                (setq detect 1)     
            )
            ;Makes syntax analiysis for (concat EXPLISTI EXPLISTI)   
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "concat"))
                (let ( (flag 0)(control 0)(start 0) (flagError 1 ) (flagAfter 1)(res nil)(keep 0))   
                    (loop for i from 2 to (-( length input ) 1)
                        do
                            (setq flagError 1)
                            (when  (equal (nth  0 (nth i input) ) "'(")
                                (when (equal flag 0)
                                    (setq keep i)
                                )
                                (setq flag ( + flag 1 )) 
                                (setq control 1)
                                (setq start 1)
                                (setq flagError 0 )
                                (setq flagAfter 0 )   
                            )
                            (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1) )
                                    (setq flag (- flag 1))
                                    (setq flagError 0 ) 
                                    (setq flagAfter 1 )     
                            )
                            (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                            )  
                            (when  (and (equal flag  0)(equal control 1 ))
                                (Setq control 0)
                                (setq flagError 0)
                                (Setq res (parser ( subseq input keep (+ i 1))))
                                (when (typep res 'CONS)
                                    (Setq lst ( concatenate 'list lst  res))
                                )
                                (when (not (typep res 'CONS))
                                    (print "SYNTAX_ERROR Expression not recognized ")
                                     ( return-from parser "error")
                                )       
                            )
                            (when (and (equal flagError 1)( equal flagAfter 1))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )    
                    )
                    (setq result lst) 
                )
                (setq detect 1) 
            )
            ;Makes syntax analiysis for (append EXPI EXPLISTI)   
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "append"))
                (let (  (expiFirst 0)(flagExpi 0)(flag 0)(control 0)(start 0) (flagError 1 ) (flagAfter 1)(res nil)(keep 0)(expi 0)(num 0))   
                    (when (equal (nth  1 (nth 2 input) ) "VALUE")
                        (setq flagError 0)
                        (Setq start 1)
                        (setq expiFirst 1)
                        (setq flagExpi 1)
                        (Setq lst (append lst (list (parse-integer (nth  0 (nth 2 input) )))))
                    )
                    (loop for i from 2 to (-( length input ) 1)
                        do
                            (setq flagError 1 )
                            (when (or (equal (nth  0 (nth i input) ) "(") (equal (nth  0 (nth i input) ) "'("))
                                    (when (equal flag 0)
                                        (setq keep i)
                                    )
                                    (setq flag ( + flag 1 )) 
                                    (setq control 1)
                                    (setq start 1) 
                                    (setq flagError 0)
                                    (setq flagAfter 0)  
                            )
                            (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1) )
                                    (setq flag (- flag 1))
                                    (setq flagError 0) 
                                    (setq flagAfter 1)     
                            )
                            (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                            )   
                            (when  (and (equal flag  0)(equal control 1 ))
                                    (Setq control 0)
                                    (setq flagError 0)
                                    (Setq res (parser ( subseq input keep (+ i 1))))
                                    (setq num (+ num 1) )
                                    (when (and (not (integerp res) ) (not (typep res 'CONS )))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                    (when (equal expiFirst 0 )
                                        (when (integerp res)
                                            (Setq lst (append lst (list res)))
                                            (Setq expiFirst 1) 
                                        )    
                                    )
                                    (when (equal expiFirst 1 )
                                        (when  (typep res 'CONS)
                                            (Setq lst ( concatenate 'list lst  res))
                                        )
                                    )
                                    (setq flagError 0)
                                   
                            )
                            (when (and (not (equal  num 0))(equal expiFirst 0))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            
                            )
                            (when (and (equal flagError 1)( equal flagAfter 1)(equal start 0))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )     
                    )
                    (setq result lst) 
                )
                (setq detect 1)     
            )
            ;Makes syntax analiysis for (set Id EXPI)  and  (defvar Id EXPI)
            (when (and (equal (nth  0 (nth i input) ) "(") (or (equal (nth 1  (nth (+ i 1) input)  ) "KW_SET")(equal (nth 1  (nth (+ i 1) input)  ) "KW_DEFVAR")) (equal (nth 1  (nth (+ i 2) input)  ) "IDENTIFIER")) 
                (let ( (flag 0)(control 0)(start 0) (flagError 1 ) (flagAfter 1)(res nil)(j 0) (keep 0)(num 0))
                    (Setq identifier (nth 0  (nth (+ i 2) input) ))
                    (Setq j 0)
                    (when (equal (nth 0  (nth (+ i 3) input)  ) "(")
                        (Setq  flag ( + flag 1 )) 
                        (setq keep (+ i 3))
                        (setq flagError 0)
                        (setq flagAfter 0)
                        (setq control 1)
                        (loop for i from 4 to (-( length input ) 1)
                            do
                                (setq flagError 1)
                                (when  (equal (nth  0 (nth i input) ) "(")
                                        (setq flag ( + flag 1 )) 
                                        (setq flagError 0)
                                        (setq flagAfter 0)
                                )
                                (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1) )
                                        (setq flag (- flag 1)) 
                                        (setq flagError 0)
                                        (setq flagAfter 1)   
                                ) 
                                (when (equal (nth  0 (nth i input) ) ")") 
                                    (Setq flagError 0)
                                ) 
                                (when  (and (equal flag  0)(equal control 1 ))
                                        (setq flagError 0)
                                        (Setq res (parser ( subseq input keep (+ i 1))))
                                        (when ( not  (typep res 'integer))
                                            (print "SYNTAX_ERROR Expression not recognized ")
                                            (return-from parser nil)
                                        )
                                        (when (typep res 'integer)
                                            (terpri)
                                            (format t "~a :~d "  identifier res) 
                                        )
                                        (setq num (+ num 1) )  
                                )
                               
                                (when (and (equal flagError 1)( equal flagAfter 1)(equal start 0))
                                    (print "SYNTAX_ERROR Expression not recognized ")
                                     ( return-from parser "error")
                                )
                                (when (and (not (equal num 0))(not(equal num 1)))
                                    (print "SYNTAX_ERROR Expression not recognized ")
                                     ( return-from parser "error")
                                )     
                        ) 
                        
                    )
                    (when (equal (nth 1  (nth (+ i 3) input)  ) "VALUE")  
                        (setq res (nth 0  (nth (+ i 3) input)))
                        (Setq flagError 0)
                        (setq num (+ num 1))
                        (format t "~a :~d "  identifier res) 
                    )
                    (when (and ( not(equal (nth 0  (nth (+ i 3) input)  ) "(") )(not (equal (length input )5 ) ))
                        (print "SYNTAX_ERROR Expression not recognized ")
                         ( return-from parser "error")
                    )   
                    (when (equal flagError 1)
                        (print "SYNTAX_ERROR Expression not recognized ")
                         ( return-from parser "error")
                    ) 
                    (setq result res) 
                )
                (setq detect 1)      
            )
            ;Makes syntax analiysis for  (if EXPB EXPLISTI) and  (if EXPB EXPLISTI EXPLISTI)
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "if"))
                (let ((indexExpb 2)(indexExplist 3)(tempList(list ))(flag 0)(control 0)(start 0)(occuring 0)(entered 0) (flagError 1 ) (flagAfter 1)(res nil)(j 0)(num 0) (keep 0)(hold 0 )(select nil) ) 
                    (loop for i from 2 to (-( length input ) 1)
                        do
                            (setq flagError 1 )
                            (when (and  (or (equal  (nth  1 (nth i input))  "KW_TRUE" )(equal  (nth  1 (nth i input))  "KW_FALSE") )(equal control 0))
                                (when (equal  (nth  1 (nth i input))  "KW_TRUE" )
                                    (Setq select t)
                                )
                                (when (equal  (nth  1 (nth i input))  "KW_FALSE" )
                                    (Setq select nil)
                                )
                                (setq flagError 0)
                                (setq hold 1)
                            ) 
                            (when (or (equal (nth  0 (nth i input) ) "(") (equal (nth  0 (nth i input) ) "'("))
                                    (when (equal flag 0)
                                        (setq keep i)
                                    )
                                    (setq flagError 0 ) 
                                    (setq flag ( + flag 1 )) 
                                    (setq control 1)
                                    (setq start 1)
                                    (setq flagAfter 0 )   
                            )
                            (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1) )
                                    (setq flag (- flag 1))
                                    (setq flagAfter 1 )
                                    (setq flagError 0 )
                                        
                            )
                            (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                            )  
                            (when  (and (equal flag  0)(equal control 1 ))
                                    (setq flagError 0)
                                    (Setq control 0)
                                    (Setq res (parser ( subseq input keep (+ i 1))))
                                    (when (and (not (typep res 'boolean ) ) (not (typep res 'CONS )))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                        (return-from parser "error")
                                    )
                                    (when (typep res 'boolean)
                                        (when (equal res t )
                                            (Setq occuring 1)
                                        
                                        )
                                        (when (equal res nil )
                                            (Setq occuring 0)
                                        
                                        )
                                        (Setq entered 1)

                                    )
                                    (setq num (+ num 1))
                                    (when (and (equal hold 0)(not (equal num 3))(not(equal num 1))(not (equal num 2)))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                    (when (and (equal hold 1)(not(equal num 1))(not (equal num 2)))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )     
                                    (when  (and (typep res 'list) (not (equal res nil))) 
                                        (Setq tempList (append tempList (list res)))
                                        (when (equal hold 0 )
                                            (when (equal occuring 1 )
                                                (when (not (equal (list-length tempList) 0))
                                                    (setq result (nth 0 tempList))
                                                )
                                                (when (equal (list-length tempList) 0)
                                                    (setq result res)
                                                )       
                                                
                                            )
                                            (when (equal occuring 0 )
                                                (when (not (equal (list-length tempList) 0))
                                                    (setq result (nth 1 tempList))
                                                )
                                                (when (equal (list-length tempList  )0)
                                                    (setq result nil)
                                                )       
                                                    
                                            )
                                            (setq indexExplist keep)
                                        )
                                        (when (equal hold 1 )
                                            (when (equal select t)
                                                (setq result (nth 0 tempList))
                                            )
                                            (when (equal select nil)
                                                (setq result (nth 1 tempList))
                                            )
                                        )
                                           
                                    )
                                    (when (equal indexExplist indexExpb)
                                        (print "SYNTAX_ERROR Expression not recognized  ")
                                         ( return-from parser "error")
                                    )
                                    
                            )
                            (when (and (equal flagError 1)( equal flagAfter 1))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            ) 
                    )
                )
                (setq detect 1) 
            )
            ;Makes syntax analiysis for  (while EXPB EXPLISTI) 
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "while"))
                (let ( (indexExpb 2)(indexExplist 3)(tempList(list ))(flag 0)(control 0)(start 0)(occuring 0)(entered 0) (flagError 1 ) (flagAfter 1)(res nil)(j 0)(num 0) (keep 0)(hold 0 )(select nil) )  
                    (loop for i from 2 to (-( length input ) 1)
                        do
                            (setq flagError 1 )
                            (when (and  (or (equal  (nth  1 (nth i input))  "KW_TRUE" )(equal  (nth  1 (nth i input))  "KW_FALSE") )(equal control 0))
                                (when (equal  (nth  1 (nth i input))  "KW_TRUE" )
                                    (Setq select t)
                                )
                                (when (equal  (nth  1 (nth i input))  "KW_FALSE" )
                                    (Setq select nil)
                                )
                                (setq flagError 0)
                                (setq hold 1)
                            ) 
                            (when (or (equal (nth  0 (nth i input) ) "(") (equal (nth  0 (nth i input) ) "'("))
                                    (when (equal flag 0)
                                        (setq keep i)
                                    )
                                    (setq flag ( + flag 1 )) 
                                    (setq control 1)
                                    (setq start 1) 
                                    (setq flagError 0 )
                                    (setq flagAfter 0 ) 
                            )
                            (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1) )
                                    (setq flag (- flag 1)) 
                                    (setq flagError 0 )
                                    (setq flagAfter 1 )   
                            )
                            (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                            )  
                            (when  (and (equal flag  0)(equal control 1 ))
                                    (Setq control 0)
                                    (setq flagError 0 )
                                    (Setq res (parser ( subseq input keep (+ i 1))))
                                    (when (and (not (typep res 'boolean ) ) (not (typep res 'CONS )))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                    (when (typep res 'boolean)
                                        (when (equal res t )
                                            (Setq occuring 1)
                                        
                                        )
                                        (when (equal res nil )
                                            (Setq occuring 0)
                                        
                                        )
                                        (Setq entered 1)

                                    )
                                    (setq num (+ num 1) )
                                    (when (and (equal hold 0)(not(equal num 1))(not (equal num 2)))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                    (when (and (equal hold 1)(not(equal num 1)))
                                        (print "SYNTAX_ERROR Expression not recognized  ")
                                         ( return-from parser "error")
                                    )     
                                    (when  (and (typep res 'list) (not (equal res nil))) 
                                        (when (equal hold 0 )
                                            (when (equal occuring 1 )
                                                    (setq result res)
                                            )
                                            (when (equal occuring 0 )
                                                    (setq result nil)       
                                                    
                                            )
                                            (setq indexExplist keep)
                                        )
                                        (when (equal hold 1 )
                                            (when (equal select t)
                                                (setq result res)
                                            )
                                            (when (equal select nil)
                                                (setq result nil)
                                            )
                                        )
                                    )
                                    (when (equal indexExplist indexExpb)
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                            )
                            (when (and (equal flagError 1)( equal flagAfter 1))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )
                        
                    )
                    result
                )
                (setq detect 1) 
            )
            ;Makes syntax analiysis for   (deffun Id IDLIST EXPLISTI) 
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 1  (nth (+ i 1) input)  ) "KW_DEFFUN")(equal (nth 1  (nth (+ i 2) input)  ) "IDENTIFIER"))
                (let ( (idList (list ))(flag 0)(identifier 0)(control 0)(start 0) (flagError 1 ) (flagAfter 1)(res nil)(keep 0)(expi 0)(j 0))
                        (Setq j 4)
                        (setq identifier (nth 0  (nth (+ i 2) input)  ) )
                        (when  (equal (nth  0 (nth 3 input) ) "(")
                                (loop 
                                    (when  (equal (nth  1 (nth j input) ) "IDENTIFIER") 
                                        (setq idList (append idList (list  (nth  0 (nth j input) ))))

                                    )
                                    (when  (not (equal (nth  1 (nth j input) ) "IDENTIFIER")) 
                                        (print (nth  1 (nth j input)))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                        (return-from parser "error")
                                    )
                                    (Setq j (+ j 1))
                                    (when (equal (nth  0 (nth j input) ) ")") (return idList))
                                )
                        )
                        (loop for i from (+ j 1 ) to (-( length input ) 1)
                            do
                                (setq flagError 1 )
                                (when (or (equal (nth  0 (nth i input) ) "(") (equal (nth  0 (nth i input) ) "'("))
                                        (when (equal flag 0)
                                            (setq keep i)
                                        )
                                        (setq flag ( + flag 1 )) 
                                        (setq control 1)
                                        (setq start 1) 
                                        (setq flagError 0)
                                        (setq flagAfter 0)  
                                )
                                (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1) )
                                        (setq flag (- flag 1))
                                        (setq flagError 0) 
                                        (setq flagAfter 1)     
                                )
                                (when (equal (nth  0 (nth i input) ) ")") 
                                    (Setq flagError 0)
                                )
                                (when  (and (equal flag  0)(equal control 1 ))
                                    (Setq control 0)
                                    (setq flagError 0)
                                    (Setq res (parser ( subseq input keep (+ i 1))))
                                    (when ( not  (typep res 'CONS))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                ) 
                                (when (and (equal flagError 1)( equal flagAfter 1))
                                    (print "SYNTAX_ERROR Expression not recognized ")
                                     ( return-from parser "error")
                                )        
                        ) 
                        (Setq result identifier)   
                )
                (setq detect 1) 
            )
            ;Makes syntax analiysis for    (for (Id EXPI EXPI) EXPLISTI)
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 1  (nth (+ i 1) input)  ) "KW_FOR")(equal (nth 0  (nth (+ i 2) input)  ) "(")(equal (nth 1  (nth (+ i 3) input)  ) "IDENTIFIER") )
                (let ((ones 0)(i 4)(flagExpi 0)(flagInner 0)(j 0) (tempList(list ))(flag 0)(control 0)(start 0)(occuring 0)(entered 0)(counter 0) (flagError 1 ) (flagAfter 1)(res nil)(j 0)(num 0) (keep 0)(hold 0 )(select nil) )                                  
                   (setq flag (+ flag 1))
                    (loop 
                        (setq flagError 1)
                        (when (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 1)
                                (setq keep i)
                            )
                            (setq j i)
                            (setq flagInner 0)
                            (setq keep j)
                            (loop
                                (when (equal (nth  0 (nth j input) ) "(")
                                      (setq flagInner ( + flagInner 1 ))

                                )      
                                (when  (equal (nth  0 (nth j input) ) ")" )
                                    (setq flagInner (- flagInner 1))
                                )
                                (when (equal flagInner 0 )
                                    (setq flagError 0)
                                    (Setq res (parser ( subseq input keep (+ j 1))))
                                    (when ( not  (integerp res))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                                )
                                (setq j (+ j 1))
                                (when (equal flagInner 0) (return j))
                            )   
                            (setq flag ( + flag 1 )) 
                            (Setq flagError 0)
                            (setq flagAfter 0)
                            
                        )
                        (when (equal (nth  1 (nth i input) ) "VALUE" )
                            (setq flagError 0)
                        )
                        (when   (equal (nth  0 (nth i input) ) ")" )
                            (setq flag (- flag 1))
                            (setq flagError 0)
                            (setq flagAfter 1)
               
                        )
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                             ( return-from parser "error")
                        )           
                        (setq i (+ i 1))
                        (when (equal flag 0) (return i))
                    )
                    (setq j i)
                    (loop for i from j to (-( length input ) 1)
                        do
                            (setq flagError 1 )
                            (when (or (equal (nth  0 (nth i input) ) "(") (equal (nth  0 (nth i input) ) "'("))
                                    (when (equal flag 0)
                                        (setq keep i)
                                    )
                                    (setq flag ( + flag 1 )) 
                                    (setq control 1)
                                    (setq start 1) 
                                    (setq flagError 0)
                                    (setq flagAfter 0)  
                            )
                            (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1) )
                                    (setq flag (- flag 1))
                                    (setq flagError 0) 
                                    (setq flagAfter 1)     
                            )
                            (when (equal (nth  0 (nth i input) ) ")") 
                                    (Setq flagError 0)
                            )   
                            (when  (and (equal flag  0)(equal control 1 ))
                                    (Setq control 0)
                                    (setq flagError 0)
                                    (Setq res (parser ( subseq input keep (+ i 1))))
                                    (setq result res)
                                    (when ( not  (typep res 'CONS))
                                        (print "SYNTAX_ERROR Expression not recognized ")
                                         ( return-from parser "error")
                                    )
                            )
                        )
                    res                
                )
                (setq detect 1) 
            )
            ;Makes syntax analiysis for (load "Id" )
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 1  (nth (+ i 1) input)  ) "KW_LOAD")(equal (nth 1  (nth (+ i 2) input)  ) "OP_OC")(equal (nth 1  (nth (+ i 3) input)  ) "IDENTIFIER")(equal (nth 1  (nth (+ i 4) input)  ) "OP_CC")(equal (nth 1  (nth (+ i 5) input)  ) "OP_CP") )    
                (setq result (nth 0  (nth (+ i 3) input) ))
                result
                (setq detect 1) 
            )
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 0  (nth (+ i 1) input)  ) "less"))
                (let ( (flag 0)(logic nil)(control 0) (flagError 1 ) (flagAfter 1)(res nil)(keep 0)(num 0)(val1 nil)(val2 nil))  
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (setq flagError 1)
                        (when  (and (equal (nth  1 (nth i input) ) "VALUE") (not (equal val1 nil))(equal val2 nil)(equal control 0))
                            (when (equal (nth  1 (nth i input) ) "VALUE")
                                (setq val2 (parse-integer (nth  0 (nth i input) )))
                                (setq flagError 0 )
                            ) 
                        )
                        (when  (and (equal (nth  1 (nth i input) ) "VALUE")(equal val1 nil)(equal control 0) )
                            (when (equal (nth  1 (nth i input) ) "VALUE")
                                (setq val1 (parse-integer (nth  0 (nth i input) )))
                                (setq flagError 0 )
                            ) 
                        )
                        (when   (equal (nth  0 (nth i input) ) "(")
                            (when (equal flag 0)
                                (setq keep i)
                            )
                            (setq flag ( + flag 1 )) 
                            (setq control 1)
                            (setq flagError 0 )
                            (setq flagAfter 0 )
                        
                        ) 
                        (when  (and (equal (nth  0 (nth i input) ) ")" )(equal control 1))
                            (setq flag (- flag 1))
                            (setq flagError 0 )
                            (setq flagAfter 0 )
                            
                        ) 
                        (when (equal (nth  0 (nth i input) ) ")") 
                                (Setq flagError 0)
                        )
                        (when  (and (not (equal val1 nil))(not (equal val2 nil)))
                            (when (and (not (equal (type-of val1 )(type-of val2)))(not (equal (integerp val1 )(integerp val2))))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")
                            )
                            (setq logic (< val1 val2))
                        ) 
                        (when  (and (equal flag  0)(equal control 1 ))
                            (Setq control 0)
                            (setq flagError 0)
                            (setq res  (parser ( subseq input keep (+ i 1))))
                            (when (typep res 'integer)
                                (when   (and (not(equal val1 nil))(equal val2 nil))
                                   (setq val2  res )
                                   (when (or (not (typep val2 'NULL)) (not (typep val1 'NULL)))
                                        (when (and (not (equal (type-of val1 )(type-of val2)))(not (equal (integerp val1 )(integerp val2))))
                                            (print "SYNTAX_ERROR Expression not recognized ")
                                             ( return-from parser "error")
                                        )
                                   )       
                                )
                                (when   (equal val1 nil)
                                    (setq val1 res)
                                )
                                
                            )
                            (when (not(typep res 'integer))
                                (print "SYNTAX_ERROR Expression not recognized ")
                                 ( return-from parser "error")     
                            )      
                        )
                       
                        (when (and (equal flagError 1)( equal flagAfter 1))
                            (print "SYNTAX_ERROR Expression not recognized ")
                            ( return-from parser "error")
                        )
                        (setq result logic)     
                    )
                ) 
                (setq detect 1)    
            
            )
            ;Makes syntax analiysis for (disp ) 
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 1  (nth (+ i 1) input)  ) "KW_DISP")) 
                (let ( (i 0)(lst (list ))) 
                    (loop for i from 2 to (-( length input ) 1)
                        do
                        (setq lst (concatenate 'string lst  " " (nth  0 (nth i input) ) ))


                    )
                    (setq result lst)
                    (setq detect 1)  
                ) 
                      
            )
            ;Makes syntax analiysis for (exit)
            (when (and (equal (nth  0 (nth i input) ) "(") (equal (nth 1  (nth (+ i 1) input)  ) "KW_EXIT")(equal (nth 0  (nth (+ i 2) input)  ) ")") ) 
                (print "EXIT IS ENTERED,PROGRAM IS TERMINATING")
                (setq detect 1) 
                (return-from parser t)       
            )
            ;Makes syntax analiysis for comment
            (when  (equal (nth  1 (nth i input) ) "COMMENT")
                (setq detect 1)
                (Setq result t)
            )
            (when (equal detect 0)
                (print  (nth i input)  )
                (print "SYNTAX_ERROR Expression not recognized ")
                 ( return-from parser "error")
            )
            (return-from parser result)   
        )  
    )     
)
(defun parenthesesDetection (input)
    (let ( (flag 0)(returnVal 0))
        ;( print input)
        (loop for i from 0 to (-( length input ) 1)
            do
            (when (or(equal (nth  0 (nth i input) ) "(") (equal (nth  0 (nth i input) ) "'("))
                (Setq flag (+ flag 1))
            )
            (when   (equal (nth  0 (nth i input) ) ")") 
                (Setq flag (- flag 1))
            )
            (when   (and (equal i (- ( length input )1) )(not (equal flag 0)))
                (print "SYNTAX ERROR FOR PARANTHESIS NUMBER...")
                (setq returnVal 1)
            )

        )
        returnVal
    )    
)
;This function to determine a character whether alphabetical or not.
(defun isAlphabetical (letter )
	(let ( (alphabet (list )))
		(setq alphabet '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t  #\u  #\v  #\w  #\x #\y #\z #\.) )
		(if (not (equal(position letter alphabet )nil ))
			t
		)		
	)
)	
;This function to determine a character digit or not.
(defun isDigit (letter )
	(let ( (digit (list )))
		(setq digit '(#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 ) )
		(if (not (equal(position letter digit )nil ))
			t
			nil
		)		
	)
)	

;(lexer (readFile "file.txt"))
 
;This is interpreter.If a file name is entered as function parameter,load file in interpreter.Or not write expressions on interpreter line by line.
(defun gppinterpreter (&optional nameofFile)
	(write-string "$ ")
	
    (when  (equal nameofFile nil) ;If file name not entered
       
        (write-line "g++") ;write g++ on screen and then  write expressions and make lexical analiysis until (exit) entered.
        	(loop 
		
                (setq interpreter ( read-line ))  ;read line from interpreter.
                (setq lex (lexer interpreter )) 
                ;(print lex)
                (setq res (parser lex));makes lexical analysis.
                (when (not (equal res "error" ))
                    (print "SYNTAX OK.")(terpri)
                        (format t "Result :~a " res) 
                )
                (terpri)
		    (when (equal interpreter "(exit)")  (return 0)))

    )
    (when  (not (equal nameofFile nil)) ;If file name entered interpreted.Load file and make lexical analiysis.
       
        (Setq i 0)
		(loop ;This loop for writing filename on interpreter.
			(setq i  (+ i 1))
			(when (equal i (-(length nameofFile ) 4)) (return ( setq name (subseq  nameofFile 0 i   )))) 
		)
		
        (format t "g++ ~a.g++" name)(terpri) ;write g++ filename.g++ on interpreter.
        (readFile nameofFile )
    )
)

(write-line "TESTING INTERPRETER WITH INPUT FILE...")
( gppinterpreter "inputFile.g++" )
(terpri)

(write-line "TESTING INTERPRETER WITH NO INPUT FILE...WRITE EXPRESSIONS LINE BY LINE..")(terpri)
( gppinterpreter )

